from cgi import test
from cmath import sqrt
import random

from numpy import mod

Sieve = []
Prime_number =    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]
Primitive_root_modulo = [1, 2, 2, 3,  2,  2,  3,  2,  5,  2,  3,  2,  6,  3,  5,  2,  2,  2,  2,  7,  5,  3,  2,  3,  5]


class Person:
    def __init__(self) -> None:
        self.private_key = 0
        self.public_key = 0
        self.number = 0

    def get_private_key(self):
        return self.private_key

    def get_public_key(self):
        return self.public_key

    def set_private_key(self, n):
        self.klucz_własny = n
    
    def set_number(self, n):
        self.liczba = n

    def key_generator(self, g, n) -> None:
        self.number = random.randint(1,pow(10,3)-1)
        print("Number: ", self.number)
        self.private_key = int(mod(pow(g,self.number),n))

    def public_key_generator(self, foreign_key, n) -> None: 
        self.public_key = int(mod(pow(foreign_key, self.number),n))


def g_and_n_generator(digits):
    prime = False
    global Sieve
    while(not prime):
        x = random.randint(2,pow(10,digits))
        if(x in Sieve):
            prime = True
        else:
            prime = False
    print(x)
    index = Prime_number.index(x)
    g = Primitive_root_modulo[index]
    print("N: {}, G: {}".format(x,g))
    return x, g


def sieve_of_eratosthenes(n):
    Sieve = [0] + n * [1]
    q = int(pow(n,1/2))
    for p in range(2, q):
        if Sieve[p] == 1:      
            for i in range(p*p, n+1, p):
                Sieve[i] = 0
    return [i for i in range(1, n+1) if Sieve[i]==1]        


def test_of_primitive_root_modulo():
    list = []
    for i in range(len(Primitive_root_modulo)):
        x = Prime_number[i]
        y = Primitive_root_modulo[i]
        print(x,y)
        for j in range(0,x-1):
            list.append((pow(y,j))%x)
        print(list)


if __name__ == "__main__":
  
    number_of_digits = 2 #aktualnie max do 97, dlatego, że takie mamy ograniczenie liczb w tabelii z pierwiastkiem modulo
    # n = 3
    # g = 2

    Sieve = sieve_of_eratosthenes(pow(10,number_of_digits))
    n, g = g_and_n_generator(number_of_digits)

    person_A = Person()
    person_B = Person()
    person_A.set_number(929)
    person_B.set_number(25)
    person_A.key_generator(g, n)
    person_B.key_generator(g, n)
    # person_A.set_private_key(32)
    # person_B.set_private_key(49)
    
    print("Private key of A:", person_A.get_private_key())
    print("Private key of B:", person_B.get_private_key())

    person_A.public_key_generator(person_B.get_private_key(), n)
    person_B.public_key_generator(person_A.get_private_key(), n)

    print("Public key generated by A: ", person_A.get_public_key())
    print("Public key generated by B: ", person_B.get_public_key())

    



 
